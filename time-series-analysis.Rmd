---
title: 'Unravelling Urban Traffic Dynamics: A Time-Series Analysis'
author: "Claire Bentzen"
date: '2023-11-15'
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
library(ggplot2)
library(dplyr)
```

## Introduction
```{r}
# read in traffic data
traffic <- read.csv("/Users/cfitzpatrick/Downloads/traffic (1).csv")

traffic

# convert date column ot datetime
traffic$DateTime <- as.POSIXct(traffic$DateTime, format="%Y-%m-%d %H:%M:%S")

# convert Junction column to categorical
traffic$Junction <- factor(traffic$Junction)
```

```{r}
# check for missing values by column
colSums(is.na(traffic))

# check for duplicate rows
sum(duplicated(traffic))
```

## Exploratory Data Analysis 
### Explore Vehicle Counts Aggregated by Day
```{r, warning=FALSE, message=FALSE}
# aggregate by date
traffic$Date <- as.Date(traffic$DateTime)

# group by Date and Junction, then calculate daily counts
traffic_daily <- traffic %>%
  group_by(Date, Junction) %>%
  summarize(DailyCount = sum(Vehicles))

# plot daily vehicle counts
ggplot(traffic_daily, aes(x = Date, y = DailyCount, color = Junction)) +
  geom_line() +
  labs(title = "Daily Vehicles Counts by Junction",
       x = "Date",
       y = "Vehicle Count",
       color = "Junction") +
  theme_minimal()
```

### Explore Vehicle Counts by Hour
```{r, warning=FALSE}
# plot hourly vehicle counts
ggplot(traffic, aes(x = DateTime, y = Vehicles, color = Junction)) +
  geom_line() +
  labs(title = "Hourly Vehicles Counts by Junction",
       x = "DateTime",
       y = "Vehicles",
       color = "Junction") +
  theme_minimal()
```

```{r}
# average vehicle counts grouped by Junction
vehicle_avg <- traffic %>%
  group_by(Junction) %>%
  summarize(AvgVehicleCount = mean(Vehicles))
vehicle_avg
```

### Time Series Plot by Junction
```{r, warning=FALSE, message=FALSE}
# split data into each junction
traffic1 <- traffic[traffic$Junction == 1, ]
traffic2 <- traffic[traffic$Junction == 2, ]
traffic3 <- traffic[traffic$Junction == 3, ]
traffic4 <- traffic[traffic$Junction == 4, ]

# plot each junction vehicle counts
par(mfrow = c(2, 2))

# junction 1 time series
traffic1.ts <- ts(traffic1$Vehicles, frequency = 24)
plot.ts(traffic1.ts, xlab = "Time", ylab = "Vehicle Count", main = "Junction 1 TS Plot of Vehicles") 

# junction 2 time series
traffic2.ts <- ts(traffic2$Vehicles, frequency = 24)
plot.ts(traffic2.ts, xlab = "Time", ylab = "Vehicle Count", main = "Junction 2 TS Plot of Vehicles") 

# junction 3 time series
traffic3.ts <- ts(traffic3$Vehicles, frequency = 24)
plot.ts(traffic3.ts, xlab = "Time", ylab = "Vehicle Count", main = "Junction 3 TS Plot of Vehicles") 

# junction 4 time series
traffic4.ts <- ts(traffic4$Vehicles, frequency = 24)
plot.ts(traffic4.ts, xlab = "Time", ylab = "Vehicle Count", main = "Junction 4 TS Plot of Vehicles") 
```



```{r}
# Convert Date column to Date object
traffic$Date <- as.Date(traffic$Date)

# Extract day of week from Date
traffic$DayOfWeek <- weekdays(traffic$Date)

# Plot average daily vehicle counts by day of week
library(ggplot2)

ggplot(traffic, aes(x = DayOfWeek, y = Vehicles, fill = Junction)) +
  geom_boxplot() +
  labs(title = "Average Daily Vehicle Counts by Day of Week",
       x = "Day of Week",
       y = "Vehicle Count",
       fill = "Junction") +
  theme_minimal()

```
```{r}
# Extract month from Date
traffic$Month <- format(traffic$Date, "%B")

# Plot average monthly vehicle counts
ggplot(traffic, aes(x = Month, y = Vehicles, fill = Junction)) +
  geom_bar(stat = "summary", fun = "mean") +
  labs(title = "Average Monthly Vehicle Counts",
       x = "Month",
       y = "Average Vehicle Count",
       fill = "Junction") +
  theme_minimal()

```
```{r}
# Create a binary variable indicating weekday or weekend
traffic$DayType <- ifelse(weekdays(traffic$Date) %in% c("Saturday", "Sunday"), "Weekend", "Weekday")

# Plot average daily vehicle counts by day type
ggplot(traffic, aes(x = DayType, y = Vehicles, fill = Junction)) +
  geom_boxplot() +
  labs(title = "Average Daily Vehicle Counts by Day Type",
       x = "Day Type",
       y = "Vehicle Count",
       fill = "Junction") +
  theme_minimal()


```

```{r}

# Convert DateTime to POSIXct
traffic$DateTime <- as.POSIXct(traffic$DateTime, format="%Y-%m-%d %H:%M:%S")

# Calculate lagged variables for each Junction
library(dplyr)

traffic_lagged <- traffic %>%
  group_by(Junction) %>%
  arrange(DateTime) %>%
  mutate(Vehicles_Lag1 = lag(Vehicles),
         Vehicles_Lag2 = lag(Vehicles, 2),
         Vehicles_Lag3 = lag(Vehicles, 3))

# Filter out rows with missing lagged values
traffic_lagged <- filter(traffic_lagged, complete.cases(Vehicles, Vehicles_Lag1, Vehicles_Lag2, Vehicles_Lag3))

# Ensure 'traffic_lagged' is a data frame
traffic_lagged <- as.data.frame(traffic_lagged)

# Check for infinite values
if (any(is.infinite(unlist(traffic_lagged)))) {
  stop("Infinite values detected in the data.")
}

# Calculate correlation matrix for the lagged vehicle counts of different Junctions
cor_matrix_junctions <- cor(traffic_lagged %>%
                              select(starts_with("Vehicles_Lag")), use = "pairwise.complete.obs")

# Plot the correlation matrix as a heatmap
library(corrplot)
corrplot(cor_matrix_junctions, method = "color", type = "upper", order = "hclust", tl.cex = 0.7)




```
```{r}

# Convert DateTime to POSIXct
traffic$DateTime <- as.POSIXct(traffic$DateTime, format="%Y-%m-%d %H:%M:%S")

# Create a time series object
traffic_ts <- ts(traffic$Vehicles, frequency = 24)

# Time Series Decomposition
decomposition <- decompose(traffic_ts)

# Plot the original time series
par(mfrow = c(3, 1))
plot(traffic_ts, main = "Original Time Series", ylab = "Vehicle Count")

# Plot the trend component
plot(decomposition$trend, main = "Trend Component", ylab = "Trend")

# Plot the seasonal component
plot(decomposition$seasonal, main = "Seasonal Component", ylab = "Seasonal")

# Plot the remainder (residuals) component
plot(decomposition$random, main = "Residuals (Remainder) Component", ylab = "Residuals")

```

```{r}

library(lubridate)
library(dplyr)
library(ggplot2)
library(lubridate)

# Look at hour of day for weekends 

# Convert DateTime to a datetime object
traffic$DateTime <- as.POSIXct(traffic$DateTime, format="%Y-%m-%d %H:%M:%S")

# Create a new column for the hour of the day
traffic$HourOfDay <- format(traffic$DateTime, "%H")

# Convert HourOfDay to numeric for plotting purposes
traffic$HourOfDay <- as.numeric(traffic$HourOfDay)

# Create a new column for the day of the week
traffic$DayOfWeek <- weekdays(traffic$DateTime)

# Filter data to include only weekends
traffic_weekends <- traffic[traffic$DayOfWeek %in% c("Saturday", "Sunday"), ]

# Plot the average number of vehicles for each hour on weekends
library(ggplot2)
ggplot(traffic_weekends, aes(x = HourOfDay, y = Vehicles)) +
  geom_point() +
  stat_summary(fun.y = "mean", geom = "point", col = "red", size = 3) +
  labs(x = "Hour of Day", y = "Average Number of Vehicles", title = "Average Vehicles by Hour on Weekends") +
  theme_minimal()
```

```{r}
# Weekdays hour of day

# Convert DateTime to a datetime object
traffic$DateTime <- as.POSIXct(traffic$DateTime, format="%Y-%m-%d %H:%M:%S")

# Create a new column for the hour of the day
traffic$HourOfDay <- format(traffic$DateTime, "%H")

# Convert HourOfDay to numeric for plotting purposes
traffic$HourOfDay <- as.numeric(traffic$HourOfDay)

# Create a new column for the day of the week
traffic$DayOfWeek <- weekdays(traffic$DateTime)

# Filter data to include only weekdays
traffic_weekdays <- traffic[traffic$DayOfWeek %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"), ]

# Plot the average number of vehicles for each hour on weekdays
library(ggplot2)
ggplot(traffic_weekdays, aes(x = HourOfDay, y = Vehicles)) +
  geom_point() +
  stat_summary(fun.y = "mean", geom = "point", col = "red", size = 3) +
  labs(x = "Hour of Day", y = "Average Number of Vehicles", title = "Average Vehicles by Hour on Weekdays") +
  theme_minimal()


```

```{r}
# Differencing 

library(lubridate)

traffic$DateTime <- as.POSIXct(traffic$DateTime)

# Create a time series object for junctions 1 and 2
ts_junction1 <- ts(traffic$Vehicles[traffic$Junction == 1], frequency = 24)  # Assuming hourly data
ts_junction2 <- ts(traffic$Vehicles[traffic$Junction == 2], frequency = 24)  # Assuming hourly data

# Differencing to remove seasonality
diff_junction1 <- diff(ts_junction1)
diff_junction2 <- diff(ts_junction2)

# Create a new time series with DateTime
ts_diff_junction1 <- ts(diff_junction1, start = start(ts_junction1), frequency = frequency(ts_junction1))
ts_diff_junction2 <- ts(diff_junction2, start = start(ts_junction2), frequency = frequency(ts_junction2))

# Plot the differenced time series for Junctions 1 and 2
plot(ts_diff_junction1, type = "l", col = "blue",
     xlab = "Date and Time", ylab = "Differenced Number of Vehicles",
     main = "Differenced Time Series to Remove Seasonality: Junction 1")
```


```{r}
lines(ts_diff_junction2, col = "red")
legend("topright", legend = c("Junction 1", "Junction 2"), col = c("blue", "red"), lty = 1)
```


```{r}
library(dplyr)

traffic <- read.csv("/Users/cfitzpatrick/Downloads/traffic (1).csv")

# Convert DateTime column to POSIXct if not already
traffic$DateTime <- as.POSIXct(traffic$DateTime)

# Sort the data frame by DateTime
traffic <- arrange(traffic, DateTime)

# Print the sorted data frame
print(traffic)
```
```{r}
# Differencing preprocessing to remove seasonaliy 

# Perform differencing on the "Vehicles" column
traffic$Vehicles_diff <- c(NA, diff(traffic$Vehicles))

# Print the updated data frame
print(traffic)

```

```{r}
#Train/test split 

# Set the percentage of data for training (e.g., 80%)
train_percentage <- 0.8

# Calculate the index to split the data
split_index <- round(nrow(traffic) * train_percentage)

# Create training and testing sets
train_data <- traffic[1:split_index, ]
test_data <- traffic[(split_index + 1):nrow(traffic), ]

```


```{r}
library(ggplot2)

# Combine training and test data for plotting
combined_data <- rbind(
  transform(train_data, set = "Training Set"),
  transform(test_data, set = "Test Set")
)

# Plotting the combined data
ggplot(combined_data, aes(x = DateTime, y = Vehicles_diff, color = set)) +
  geom_line() +
  labs(title = "Training and Test Sets", x = "Date and Time", y = "Vehicles Difference")


```
```{r}

#Lets start with a basic moving average across the entire dataset as a baseline. 


window_size <- 7 

# Initialize a list to store models and predictions for each junction
junction_predictions <- list()

# Create a separate plot for each junction
for (j in unique(traffic$Junction)) {
  # Subset the data for the current junction
  junction_data <- subset(traffic, Junction == j)
  
  # Calculate the moving average
  ma <- stats::filter(junction_data$Vehicles_diff, rep(1/window_size, window_size), sides = 2)
  
  # Save the predictions in the list
  junction_predictions[[as.character(j)]] <- ma
  
  # Create a data frame for plotting
  plot_data <- data.frame(
    DateTime = junction_data$DateTime,
    Actual = junction_data$Vehicles_diff,
    MovingAverage = ma
  )
  
  # Plotting
  plot(plot_data$DateTime, plot_data$Actual, col = "blue", main = paste("Junction ", j, ": Actual vs. Predicted (Moving Average)"), xlab = "DateTime", ylab = "Vehicles Difference")
  lines(plot_data$DateTime, plot_data$MovingAverage, col = "red", lty = 2)
  legend("topright", legend = c("Actual", "Moving Average"), col = c("blue", "red"), lty = 2:1, cex = 0.5)
}

```


```{r}

library(forecast)

# Convert your 'DateTime' column to a time series
ts_data <- ts(traffic$Vehicles_diff, frequency = 1)

# Set the percentage of data for training (e.g., 80%)
train_percentage <- 0.8

# Initialize a list to store models and predictions for each junction
junction_models <- list()
junction_predictions <- list()

# Iterate over each junction
for (j in unique(traffic$Junction)) {
  # Subset the data for the current junction
  junction_data <- subset(traffic, Junction == j)$Vehicles_diff
  ts_junction_data <- ts(junction_data, frequency = 1)
  
  # Calculate the index to split the data
  split_index <- round(length(ts_junction_data) * train_percentage)
  
  # Create training and testing sets
  train_data <- window(ts_junction_data, end = split_index)
  test_data <- window(ts_junction_data, start = split_index + 1)
  
  # Fit an ARIMA model
  arima_model <- auto.arima(train_data)
  
  # Save the model in the list
  junction_models[[as.character(j)]] <- arima_model
  
  # Make predictions on the test set
  predictions <- forecast(arima_model, h = length(test_data))
  
  # Save the predictions in the list
  junction_predictions[[as.character(j)]] <- predictions
}

# # Plotting only the testing set and predicted values with a smaller legend
# par(mfrow = c(2, 2))  
# for (j in unique(traffic$Junction)) {
#   junction_data <- subset(traffic, Junction == j)$Vehicles_diff
#   ts_junction_data <- ts(junction_data, frequency = 1)
#   predictions <- junction_predictions[[as.character(j)]]
#   
#   plot(ts_junction_data, col = "blue", main = paste("Junction ", j, ": Actual vs. Predicted"), xlab = "DateTime", ylab = "Vehicles Difference")
#   lines(predictions$mean, col = "red", lty = 2)
#   legend("topright", legend = c("Actual", "Predicted"), col = c("blue", "red"), lty = 2:1, cex = 0.5)
# }


par(mfrow = c(2, 2))  # 2x2 layout for the plots

for (j in unique(traffic$Junction)) {
  junction_data <- subset(traffic, Junction == j)$Vehicles_diff
  ts_junction_data <- ts(junction_data, frequency = 1)
  predictions <- junction_predictions[[as.character(j)]]
  
  plot(ts_junction_data, col = "blue", main = paste("Junction ", j, ": Actual vs. Predicted"), xlab = "DateTime", ylab = "Vehicles Difference")
  lines(predictions$mean, col = "red", lty = 2)
  legend("topright", legend = c("Actual", "Predicted"), col = c("blue", "red"), lty = 2:1, cex = 0.5, inset = 0.02)
}

```

```{r}
#Evaluation Metrics to ARIMA 

if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

# Load the dplyr package
library(dplyr)

# Initialize an empty data frame for evaluation metrics
evaluation_metrics <- data.frame(Junction = character(), MAE = numeric(), MSE = numeric(), RMSE = numeric(), stringsAsFactors = FALSE)

# Calculate evaluation metrics for each junction
for (j in unique(traffic$Junction)) {
  junction_data <- subset(traffic, Junction == j)$Vehicles_diff
  ts_junction_data <- ts(junction_data, frequency = 1)
  predictions <- junction_predictions[[as.character(j)]]
  
  # Extract the actual values from the test set
  actual_values <- as.vector(window(ts_junction_data, start = length(ts_junction_data) - length(predictions$mean) + 1))
  
  # Calculate evaluation metrics
  mae <- mean(abs(predictions$mean - actual_values))
  mse <- mean((predictions$mean - actual_values)^2)
  rmse <- sqrt(mse)
  
  # Add the results to the data frame
  evaluation_metrics <- bind_rows(evaluation_metrics, data.frame(Junction = as.character(j), MAE = mae, MSE = mse, RMSE = rmse))
}

# Print the evaluation metrics
print(evaluation_metrics)

```

